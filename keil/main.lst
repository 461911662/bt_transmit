C51 COMPILER V9.00   MAIN                                                                  07/12/2019 22:42:45 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN ..\output\main.obj
COMPILER INVOKED BY: E:\developer kit tool\Keil_v5\C51\BIN\C51.EXE ..\code\source\main.c LARGE OPTIMIZE(9,SIZE) BROWSE N
                    -OAREGS INTVECTOR(0X0300) INCDIR(..\code\include) DEBUG OBJECTEXTEND PRINT(.\main.lst) TABS(2) OBJECT(..\output\main.obj)

line level    source

   1          /*****************************************************************************
   2          **               AMICCOM Electronics Corporation Document                   **
   3          **          Copyright (c) 2011-2015 AMICCOM Electronics Corporation         **
   4          **                                                                          **
   5          **      A3,1F,No.1, Li-Hsin 1th Road, Science_Based Industrid Park,         **
   6          **                       Hsin_Chu City, 300, Taiwan, ROC.                   **
   7          **                 Tel: 886-3-5785818   Fax: 886-3-5785819                  **
   8          **         E-mail:info@amiccom.com.tw  http: //www.amiccom.com.tw           **
   9          *****************************************************************************/
  10          #include "define.h"
  11          #include "A8107.h"
  12          #include "LibFunction.h"
  13          #include "mcufunction.h"
  14          #include "IAP.h"
  15          #include "servicegen.h"
  16          #include "OTA.h"
  17          #include "io_pwm.h"
  18          #include "usermcufunction.h"
  19          
  20          
  21          uint8_t xdata HID_report_MS_key_temp;
  22          uint8_t xdata HID_report_KB_key_temp; /* 键盘 */
  23          
  24          uint8_t xdata xpresskeyVolup;
  25          uint8_t xdata xpresskeyVoldown;
  26          uint8_t xdata xpresskeyVideo;
  27          uint8_t xdata xpresskeyInvert;
  28          uint8_t xdata xpresskeyCapture;
  29          
  30          uint8_t xdata mousedata;
  31          
  32          void MouseDemo(void);
  33          
  34          
  35          #ifdef _PROFILE_HOGP_
              #ifdef _PROFILE_HOGP_COMSUMER_
              #define HDL_HIDS_REPORT_TAB_CSKEY_L                             0
              #define HDL_HIDS_REPORT_TAB_CSKEY_H                             1
              #endif
              
              #ifdef _PROFILE_HOGP_MOUSE_
              #define HDL_HIDS_REPORT_TAB_KEY_L_R                             0
              #define HDL_HIDS_REPORT_TAB_DIR_L_R_L                           1
              #define HDL_HIDS_REPORT_TAB_DIR_L_R_H                           2
              #define HDL_HIDS_REPORT_TAB_DIR_U_D_L                           3
              #define HDL_HIDS_REPORT_TAB_DIR_U_D_H                           4
              #define HDL_HIDS_REPORT_TAB_ROL_U_D                             5
              #endif
              
              #ifdef _PROFILE_HOGP_KEYBOARD_
              #define HDL_HIDS_REPORT_TAB_KEY_CTRL                            0
              #define HDL_HIDS_REPORT_TAB_KEY_DATA0                           2
              #define HDL_HIDS_REPORT_TAB_KEY_DATA1                           3
              #define HDL_HIDS_REPORT_TAB_KEY_DATA2                           4
C51 COMPILER V9.00   MAIN                                                                  07/12/2019 22:42:45 PAGE 2   

              #define HDL_HIDS_REPORT_TAB_KEY_DATA3                           5
              #define HDL_HIDS_REPORT_TAB_KEY_DATA4                           6
              #define HDL_HIDS_REPORT_TAB_KEY_DATA5                           7
              #endif
              #endif
  60          
  61          const uint8_t code HID_RPT_CS_KEY_DEMO[][2] =
  62          {
  63              {0xE9, 0x00,},  //vol+
  64              {0xEA, 0x00,},  //vol-
  65              {0xE2, 0x00,},  //Mute
  66              {0xB0, 0x00,},  //Play
  67              {0xB1, 0x00,},  //Pause
  68              //{0xB2, 0x00,},  //Record
  69              {0xB3, 0x00,},  //Fast forward
  70              {0xB4, 0x00,},  //Rewind
  71              {0xB5, 0x00,},  //Scan next track
  72              {0xB6, 0x00,},  //Scan previous track
  73              {0xB7, 0x00,},  //Stop
  74              {0xB8, 0x00,},  //Eject
  75              {0x8A, 0x01,},  //Email reader
  76              {0x96, 0x01,},  //Internet browser
  77              {0x9E, 0x01,},  //Terminal lock/screensaver
  78              {0xC6, 0x01,},  //Research/search browser
  79              {0x2D, 0x02,},  //Zoom in
  80          };
  81          
  82          #ifdef _PROFILE_TAOBAO_
              const uint8_t code auth_data_taobao[60]=
              {
                  0x03,0x00,0x26,0xFE,0x01,0x00,0x26,0x27,
                  0x11,0x00,0x01,0x0A,0x00,0x12,0x10,0x8A,
                  0xB7,0x40,0x66,0x48,
                  0x7C,0x9A,0xDE,0x17,0x5B,0x80,0xD7,0xD7,
                  0x0C,0x83,0x0B,0x18,0x83,0x80,0x04,0x20,
                  0x01,0x28,0x01,0x32,
                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                  0x00,0x00,0x00,0x00
              };
              
              const uint8_t code init_data_taobao[20]=
              {
                  0x03,0x00,0x0D,0xFE,0x01,0x00,0x0D,0x27,
                  0x13,0x00,0x02,0x0A,0x00,0x12,0x01,0x7F,
                  0x00,0x00,0x00,0x00
              };
              
              const uint8_t code send_test_data_taobao[60]=
              {
                  0x03,0x00,0x36,0xFE,0x01,0x00,0x36,0x27,
                  0x12,0x00,0x03,0x0A,0x00,0x12,0x2A,0x43,
                  0x43,0x30,0x37,0x39,
                  0x36,0x37,0x34,0x32,0x34,0x45,0x46,0x45,
                  0x39,0x33,0x31,0x33,0x30,0x33,0x38,0x32,
                  0x30,0x30,0x30,0x34,
                  0x31,0x33,0x30,0x33,0x31,0x33,0x36,0x34,
                  0x31,0x33,0x30,0x33,0x30,0x33,0x31,0x30,
                  0x38,0x00,0x00,0x00
              };
              
              const uint8_t code scale_data_init[10]=
C51 COMPILER V9.00   MAIN                                                                  07/12/2019 22:42:45 PAGE 3   

              {
                  0x01,0x30,0x30,0x30,0x30,0x42,0x46,0x38,0x33,0x43,
              };
              #endif
 121          
 122          #ifdef _PROFILE_WECHAT_
 123          const uint8_t code auth_data_wechat[26]=
 124          {
 125              0xFE,0x01,0x00,0x1A,0x27,0x11,0x00,0x01,
 126              0x0A,0x00,0x18,0x80,0x80,0x04,0x20,0x01,
 127              0x28,0x02,0x3A,0x06,0xD0,0x39,0x72,0xA5,
 128              0xEF,0x24
 129          };
 130          
 131          const uint8_t code init_data_wechat[19]=
 132          {
 133              0xFE,0x01,0x00,0x13,0x27,0x13,0x00,0x02,
 134              0x0A,0x00,0x1A,0x04,0x30,0x37,0x31,0x35,
 135              0x12,0x01,0x41
 136          };
 137          
 138          const uint8_t code send_test_data_wechat[19]=
 139          {
 140              0xFE,0x01,0x00,0x13,0x27,0x12,0x00,0x02,
 141              0x0A,0x00,0x1A,0x04,0x30,0x37,0x31,0x35,
 142              0x12,0x01,0x41
 143          };
 144          #endif
 145          
 146          #ifdef _PROFILE_WECHAT_SIMPLE_MODE_
              const uint8_t code current_step_data[4]=
              {
                  0x01,0x10,0x27,0x00
              };
              
              const uint8_t code current_total_data[10]=
              {
                  0x07,0x10,0x27,0x00,0x70,0x17,0x00,0x00,0x22,0x33
              };
              
              const uint8_t code target_data[19]=
              {
                  0xFE,0x01,0x00,0x13,0x27,0x12,0x00,0x02,
                  0x0A,0x00,0x1A,0x04,0x30,0x37,0x31,0x35,
                  0x12,0x01,0x41
              };
              #endif
 164          
 165          /*******************************************************************
 166           *
 167           * main - main function
 168           * Description:
 169           *      The function is the system entry point. The whole system is
 170           *      start from here.
 171           *
 172           ******************************************************************/
 173          void main(void)
 174          {
 175   1          ADV_InitDef ADV_InitStructure;
 176   1          
 177   1          bit isUpdate = FALSE;
 178   1          bit isUpdate1 = FALSE;
C51 COMPILER V9.00   MAIN                                                                  07/12/2019 22:42:45 PAGE 4   

 179   1          bit isWorking = FALSE;
 180   1      
 181   1          uint8_t xdata   UpdateOTASpeed;
 182   1          uint8_t xdata   DataLen;
 183   1          uint8_t xdata   AdvFastSpeed = ENABLE;
 184   1          uint8_t xdata   *ptrChar = NULL;
 185   1          uint8_t xdata   result, i;
 186   1        uint16_t xdata   waitpacket_tmp=0, waitpacket_tmp1=0, waitpacket_tmp2=0;
 187   1        //while(~P0_4);
 188   1      
 189   1          /* 1.关闭全局中断 */
 190   1          InterruptDisable();
 191   1          
 192   1          /* 2.初始化MCU    */
 193   1          InitMCU();
 194   1          internalRC = 0; /* 0 :Using External RC 32.768KHz ; 1:Using internal RC 32.000KHz */
 195   1      
 196   1          InitCrystalCL(0x0d);  //AMICCOM CrystalCL 0x32(MD8107-A05)(18pF)/ 0x14(MD8107-A06)(12pF)/ 0x0D(9pF)
 197   1          InitRF();
 198   1          IAP_Initialize();
 199   1          OTA_Initialize();
 200   1      
 201   1          InitBLE();
 202   1          BLE_SetTxPower(0); //level 0 ~ 7 : 0 => -17dBm; 1 => -15dBm; 2 => -10dBm; 3 => -5dBm; 4 => 0dBm; 5 => 
             -2dBm; 6 => 4dBm; 7 => 7dBm
 203   1      
 204   1          /* 3.关中断 */
 205   1          InterruptEnable();
 206   1      
 207   1      #ifdef _PROFILE_TAOBAO_
                for(i=0;i<10;i++)
                  scalebuf[i]=scale_data_init[i];
              
                weightvalue=0;
                datevalue=559240;
                datevalue=788888;
              #endif
 215   1      ////////////////TWOR///////////////////////////////////
 216   1          /* 启动0.5s定时器 */
 217   1        //IOSEL|=0x08;
 218   1        IOSEL=0x00;
 219   1        TworTimer=0;
 220   1        TworTimerFlag=0; /* 清除TworTimerFlag，每隔0.5秒会被置位 */
 221   1        Twor05Timer(ENABLE);
 222   1      ////////////////TWOR///////////////////////////////////
 223   1        BLE_INT_FLAG=0;  /* 清除该标志位，此标志位可被BLE定时器置位                   */
 224   1        OTA_RECONNECT_FLAG = DISABLE; /* 開始 OTA 程序前，自動斷線並重新連線後之提示 FLAG */
 225   1              
 226   1          //user add code.
 227   1          //initIsr_timer1();
 228   1          //pwm_init();
 229   1          
 230   1        while(1)
 231   1          {
 232   2              //OTA_Process(); /* disable ota function */
 233   2      
 234   2              /* User Can Add Code */
 235   2              if(ble_state == STANDBY_STATE)
 236   2              {
 237   3                  
 238   3                  reset();
 239   3                  isWorking = FALSE;
C51 COMPILER V9.00   MAIN                                                                  07/12/2019 22:42:45 PAGE 5   

 240   3      
 241   3                  /* 初始化广播,并开启广播 */
 242   3                  ADV_InitStructure.ADV_Timing = 1568;//768; // ADV Interval = (20ms + 0.625ms*ADV_Timing) = 20m
             -s
 243   3                  ADV_InitStructure.ADV_TO = 1500;  // ADV Timeout = ADV Interval * ADV_TO = 20ms*1500 = 30 sec
 244   3                  ADV_InitStructure.ADV_Channel = (TE_ADVCHANNEL)(ADV_CH37 | ADV_CH38 | ADV_CH39);// ;
 245   3                  ADV_InitStructure.ADV_Type = ADV_IND;
 246   3                  ADV_InitStructure.ADV_RndEnable = DISABLE;
 247   3                  ADV_InitStructure.ADV_TOEnable = ENABLE;
 248   3                  ADV_InitStructure.ADV_Run = ENABLE;
 249   3                  BLE_ADV_Cmd(&ADV_InitStructure);
 250   3      
 251   3                  HID_report_MS_key_temp = 0x00;
 252   3                  mousedata = 0;
 253   3      
 254   3            auth_req = FAIL;
 255   3            init_req = FAIL;
 256   3            auth_init_finish = FAIL;
 257   3            index = 0;
 258   3            scale_index = 0;
 259   3            KeyWakeup = 0;
 260   3            sendscaledata = FAIL;
 261   3            waitpacket=0;
 262   3      #ifdef _PROFILE_WECHAT_SIMPLE_MODE_
                    for(i=0;i<10;i++)
                      att_HDL_WECHAT_SIMPLEMODE_DATRWI[i] = current_total_data[i];
                    att_HDL_WECHAT_SIMPLEMODE_DATRWI[20]=10;
              #endif
 267   3              }
 268   2              else if(ble_state == ADV_STATE)
 269   2              {
 270   3                  UpdateOTASpeed = ENABLE;
 271   3      
 272   3                  isUpdate = FALSE;
 273   3                  isUpdate1 = FALSE;
 274   3                  isWorking = FALSE;
 275   3      
 276   3                  /* reset */
 277   3                  reset();
 278   3              }
 279   2              else if(ble_state == CONNECT_ESTABLISH_STATE)
 280   2              {
 281   3                  isWorking = TRUE;
 282   3                  //connected_init(); /* disable */
 283   3      
 284   3                  //timer_detect(); /* disable */
 285   3      
 286   3                  //sub_function(); /* disable */
 287   3                  
 288   3                  //if (UpdateOTASpeed)
 289   3                  //{
 290   3                  //    Temp = (uint8_t)OTA_UpdataSpeed();
 291   3      
 292   3                  //    if ((OTA_SUCCESSFUL == Temp) || (OTA_COUNT_MAX == Temp))
 293   3                  //        UpdateOTASpeed = DISABLE;
 294   3                  //} /* Changing OTA download speeds */
 295   3      
 296   3                  if (BLE_writeEventFlag)
 297   3                  {
 298   4                      ptrChar = BLE_GetWriteEnvet();
 299   4                      DataLen = BLE_GetWriteEnvet_Length();
 300   4      
C51 COMPILER V9.00   MAIN                                                                  07/12/2019 22:42:45 PAGE 6   

 301   4      #ifdef _PROFILE_USER_DEFINE_01_
 302   4                      if(ptrChar == &att_HDL_USER_DEFINE_01_DATAW01)
 303   4              {
 304   5                if((att_HDL_USER_DEFINE_01_DATAN01_CLIENT_CHARACTERISTIC_CONFIGURATION[0] & GATT_DESCRIPTORS_CLIENT_C
             -HARACTERISTIC_CONFIGURATION_NOTIFICATION) != 0)
 305   5                {
 306   6                  for(i=0;i<20;i++)
 307   6                              {                  
 308   7                      att_HDL_USER_DEFINE_01_DATAN01[i] = att_HDL_USER_DEFINE_01_DATAW01[i];
 309   7                              }
 310   6                  result = BLE_SendData(att_HDL_USER_DEFINE_01_DATAN01, ATT_HDL_USER_DEFINE_01_DATAN01_INIT, 5);
 311   6      
 312   6                  if(result == SUCCESS)
 313   6                  {
 314   7                      _nop_();
 315   7                      //P0_0 = ~P0_0;
 316   7                  }
 317   6                  else
 318   6                  {
 319   7                      _nop_();
 320   7                      //P0_1 = ~P0_1;
 321   7                  }
 322   6                }
 323   5      
 324   5              }
 325   4                      else if(ptrChar == &att_HDL_USER_DEFINE_01_DATAW02)
 326   4              {
 327   5                  if((att_HDL_USER_DEFINE_01_DATAN02_CLIENT_CHARACTERISTIC_CONFIGURATION[0] & GATT_DESCRIPTORS_CLIENT_
             -CHARACTERISTIC_CONFIGURATION_NOTIFICATION) != 0)
 328   5                  {
 329   6                      for(i=0;i<20;i++)
 330   6                          att_HDL_USER_DEFINE_01_DATAN02[i] = att_HDL_USER_DEFINE_01_DATAW02[i];
 331   6      
 332   6                      result = BLE_SendData(att_HDL_USER_DEFINE_01_DATAN02,ATT_HDL_USER_DEFINE_01_DATAN02_INIT,5);
 333   6      
 334   6                      if(result == SUCCESS)
 335   6                      {
 336   7                          _nop_();
 337   7                          //P0_0 = ~P0_0;
 338   7                      }
 339   6                      else
 340   6                      {
 341   7                          _nop_();
 342   7                          //P0_1 = ~P0_1;
 343   7                      }
 344   6                  }
 345   5      
 346   5              }
 347   4      #endif
 348   4                      else
 349   4                          ;
 350   4                  }
 351   3      #ifdef _PROFILE_HOGP_
                      if(~P3_2)
                      {
                          do
                              {
                              MouseDemo();
                          }while(~P3_2);
                          }
              
              
C51 COMPILER V9.00   MAIN                                                                  07/12/2019 22:42:45 PAGE 7   

                      if(~P0_0)
                      {
                          if((att_HDL_HIDS_REPORT_KBI_CLIENT_CHARACTERISTIC_CONFIGURATION[0] & GATT_DESCRIPTORS_CLIENT_CHA
             -RACTERISTIC_CONFIGURATION_NOTIFICATION) != 0)
                          {
                                  /* 照相 */
                                  att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA0] = 0x58; /* enter */
                                  att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA1] = 0x133; /* fingerprint identif
             -y end */
                                  att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA2] = 0x191; /* blue */
                                  att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA3] = 0x12F; /* fingerprint up */
                                  att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA4] = 0x130; /* fingerprint finger 
             -up */
                                  result = BLE_SendData(att_HDL_HIDS_REPORT_KBI,ATT_HDL_HIDS_REPORT_KBI_INIT,ATT_HDL_HID
             -S_REPORT_KBI_INIT[4]);
                                  if(result == SUCCESS)
                                  {
                                      xpresskeyCapture = 1;
                                  }
                              }
                          }
                    else
                    {
                        if(xpresskeyCapture)
                        {
                              if((att_HDL_HIDS_REPORT_KBI_CLIENT_CHARACTERISTIC_CONFIGURATION[0] & GATT_DESCRIPTORS_CLIENT
             -_CHARACTERISTIC_CONFIGURATION_NOTIFICATION) != 0)
                              {
                                    att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA0] = 0x00;
                                      att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA1] = 0x00;
                                      att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA2] = 0x00;
                                      att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA3] = 0x00;
                                      att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA4] = 0x00;
                                      result = BLE_SendData(att_HDL_HIDS_REPORT_KBI,ATT_HDL_HIDS_REPORT_KBI_INIT,ATT_HDL
             -_HIDS_REPORT_KBI_INIT[4]);
                                      if(result == SUCCESS)
                                      {
                                          xpresskeyCapture = 0;
                                      }
                                  }
                              }
                    }
              
                      if(~P0_5)
                      {
                          if((att_HDL_HIDS_REPORT_KBI_CLIENT_CHARACTERISTIC_CONFIGURATION[0] & GATT_DESCRIPTORS_CLIENT_CHA
             -RACTERISTIC_CONFIGURATION_NOTIFICATION) != 0)
                          {
                                  /* 焦距+ */
                                  att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA0] = 0x80; /* Volume+ */
                                  result = BLE_SendData(att_HDL_HIDS_REPORT_KBI,ATT_HDL_HIDS_REPORT_KBI_INIT,ATT_HDL_HID
             -S_REPORT_KBI_INIT[4]);
                                  if(result == SUCCESS)
                                  {
                                      xpresskeyVolup = 1;
                                  }
                              }
                          }
                    else
                    {
                        if(xpresskeyVolup)
                        {
C51 COMPILER V9.00   MAIN                                                                  07/12/2019 22:42:45 PAGE 8   

                              if((att_HDL_HIDS_REPORT_KBI_CLIENT_CHARACTERISTIC_CONFIGURATION[0] & GATT_DESCRIPTORS_CLIENT
             -_CHARACTERISTIC_CONFIGURATION_NOTIFICATION) != 0)
                              {
                                    att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA0] = 0x00;
                                      result = BLE_SendData(att_HDL_HIDS_REPORT_KBI,ATT_HDL_HIDS_REPORT_KBI_INIT,ATT_HDL
             -_HIDS_REPORT_KBI_INIT[4]);
                                      if(result == SUCCESS)
                                      {
                                          xpresskeyVolup = 0;
                                      }
                                  }
                              }
                    }
              
                      if(~P0_3)
                      {
                          if((att_HDL_HIDS_REPORT_KBI_CLIENT_CHARACTERISTIC_CONFIGURATION[0] & GATT_DESCRIPTORS_CLIENT_CHA
             -RACTERISTIC_CONFIGURATION_NOTIFICATION) != 0)
                          {
                                  /* 焦距- */
                                  att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA0] = 0x81; /* Volume- */
                                  result = BLE_SendData(att_HDL_HIDS_REPORT_KBI,ATT_HDL_HIDS_REPORT_KBI_INIT,ATT_HDL_HID
             -S_REPORT_KBI_INIT[4]);
                                  if(result == SUCCESS)
                                  {
                                      xpresskeyVoldown = 1;
                                  }
                              }
                          }
                    else
                    {
                        if(xpresskeyVoldown)
                        {
                              if((att_HDL_HIDS_REPORT_KBI_CLIENT_CHARACTERISTIC_CONFIGURATION[0] & GATT_DESCRIPTORS_CLIENT
             -_CHARACTERISTIC_CONFIGURATION_NOTIFICATION) != 0)
                              {
                                    att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA0] = 0x00;
                                      result = BLE_SendData(att_HDL_HIDS_REPORT_KBI,ATT_HDL_HIDS_REPORT_KBI_INIT,ATT_HDL
             -_HIDS_REPORT_KBI_INIT[4]);
                                      if(result == SUCCESS)
                                      {
                                          xpresskeyVoldown = 0;
                                      }
                                  }
                              }
                    }
              
                      if(~P0_2)
                      {
                          if((att_HDL_HIDS_REPORT_KBI_CLIENT_CHARACTERISTIC_CONFIGURATION[0] & GATT_DESCRIPTORS_CLIENT_CHA
             -RACTERISTIC_CONFIGURATION_NOTIFICATION) != 0)
                          {
                                  /* 摄像 */
                                  att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA0] = 0x21; /* key4 */
                                  att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA1] = 0x133; /* fingerprint identif
             -y end */
                                  att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA2] = 0x191; /* blue */
                                  att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA3] = 0x12F; /* fingerprint up */
                                  att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA4] = 0x130; /* fingerprint finger 
             -up */
                                  result = BLE_SendData(att_HDL_HIDS_REPORT_KBI,ATT_HDL_HIDS_REPORT_KBI_INIT,ATT_HDL_HID
             -S_REPORT_KBI_INIT[4]);
C51 COMPILER V9.00   MAIN                                                                  07/12/2019 22:42:45 PAGE 9   

                                  if(result == SUCCESS)
                                  {
                                      xpresskeyVideo = 1;
                                  }
                              }
                          }
                    else
                    {
                        if(xpresskeyVideo)
                        {
                              if((att_HDL_HIDS_REPORT_KBI_CLIENT_CHARACTERISTIC_CONFIGURATION[0] & GATT_DESCRIPTORS_CLIENT
             -_CHARACTERISTIC_CONFIGURATION_NOTIFICATION) != 0)
                              {
                                    att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA0] = 0x00;
                                      att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA1] = 0x00;
                                      att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA2] = 0x00;
                                      att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA3] = 0x00;
                                      att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA4] = 0x00;
                                      result = BLE_SendData(att_HDL_HIDS_REPORT_KBI,ATT_HDL_HIDS_REPORT_KBI_INIT,ATT_HDL
             -_HIDS_REPORT_KBI_INIT[4]);
                                      if(result == SUCCESS)
                                      {
                                          xpresskeyVideo = 0;
                                      }
                                  }
                              }
                    }
              
                      if(~P0_1)
                      {
                          if((att_HDL_HIDS_REPORT_KBI_CLIENT_CHARACTERISTIC_CONFIGURATION[0] & GATT_DESCRIPTORS_CLIENT_CHA
             -RACTERISTIC_CONFIGURATION_NOTIFICATION) != 0)
                          {
                                  /* 摄像 */
                                  att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA0] = 0x20; /* key4 */
                                  att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA1] = 0x133; /* fingerprint identif
             -y end */
                                  att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA2] = 0x191; /* blue */
                                  att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA3] = 0x12F; /* fingerprint up */
                                  att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA4] = 0x130; /* fingerprint finger 
             -up */
                                  result = BLE_SendData(att_HDL_HIDS_REPORT_KBI,ATT_HDL_HIDS_REPORT_KBI_INIT,ATT_HDL_HID
             -S_REPORT_KBI_INIT[4]);
                                  if(result == SUCCESS)
                                  {
                                      xpresskeyInvert = 1;
                                  }
                              }
                          }
                    else
                    {
                        if(xpresskeyInvert)
                        {
                              if((att_HDL_HIDS_REPORT_KBI_CLIENT_CHARACTERISTIC_CONFIGURATION[0] & GATT_DESCRIPTORS_CLIENT
             -_CHARACTERISTIC_CONFIGURATION_NOTIFICATION) != 0)
                              {
                                    att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA0] = 0x00;
                                      att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA1] = 0x00;
                                      att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA2] = 0x00;
                                      att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA3] = 0x00;
                                      att_HDL_HIDS_REPORT_KBI[HDL_HIDS_REPORT_TAB_KEY_DATA4] = 0x00;
                                      result = BLE_SendData(att_HDL_HIDS_REPORT_KBI,ATT_HDL_HIDS_REPORT_KBI_INIT,ATT_HDL
C51 COMPILER V9.00   MAIN                                                                  07/12/2019 22:42:45 PAGE 10  

             -_HIDS_REPORT_KBI_INIT[4]);
                                      if(result == SUCCESS)
                                      {
                                          xpresskeyInvert = 0;
                                      }
                                  }
                              }
                    }
              #endif
 530   3              }
 531   2      ////////////////TWOR///////////////////////////////////
 532   2          if(TworTimerFlag)
 533   2          {
 534   3            if(OTA_RECONNECT_FLAG == DISABLE)
 535   3            {
 536   4              if(OTA_START_FLAG==1)
 537   4                _nop_();
 538   4            }
 539   3      
 540   3            TworTimerFlag=0;
 541   3          }
 542   2      ////////////////TWOR///////////////////////////////////
 543   2      
 544   2              if(isIntoSleep())
 545   2              {
 546   3                  RecoveryFlag  = 1;
 547   3                  setIntoSleepFlag(FALSE);
 548   3                  reset();
 549   3                  En_Sleep();
 550   3              }
 551   2          
 552   2              if(RecoveryFlag == 1)
 553   2              {
 554   3                  RecoveryFlag = 0;
 555   3                  En_Recovery();
 556   3              }
 557   2              else
 558   2              {
 559   3                  if(!isWorking)
 560   3                  {
 561   4                      setIntoSleepFlag(TRUE);
 562   4                      BLE_AutoPwrDown_Enable();
 563   4                  }
 564   3              }
 565   2          }
 566   1      }
 567          
 568          
 569          
 570          void MouseDemo(void)
 571          {
 572   1      #ifdef _PROFILE_HOGP_
                  uint8_t result;
              
                  if(mousedata == 0)
                  {
                      if((att_HDL_HIDS_REPORT_MSI_CLIENT_CHARACTERISTIC_CONFIGURATION[0] & GATT_DESCRIPTORS_CLIENT_CHARA
             -CTERISTIC_CONFIGURATION_NOTIFICATION) != 0)
                      {
                          HID_report_MS_key_temp++;
                          if(HID_report_MS_key_temp <= 0x3F)
                          {
C51 COMPILER V9.00   MAIN                                                                  07/12/2019 22:42:45 PAGE 11  

                              att_HDL_HIDS_REPORT_MSI[HDL_HIDS_REPORT_TAB_DIR_L_R_L] = 0xFF;
                              att_HDL_HIDS_REPORT_MSI[HDL_HIDS_REPORT_TAB_DIR_L_R_H] = 0xFF;
                              att_HDL_HIDS_REPORT_MSI[HDL_HIDS_REPORT_TAB_DIR_U_D_L] = 0xFF;
                              att_HDL_HIDS_REPORT_MSI[HDL_HIDS_REPORT_TAB_DIR_U_D_H] = 0xFF;
                          }
                          else if(HID_report_MS_key_temp <= 0x7F)
                          {
                              att_HDL_HIDS_REPORT_MSI[HDL_HIDS_REPORT_TAB_DIR_L_R_L] = 0x01;
                              att_HDL_HIDS_REPORT_MSI[HDL_HIDS_REPORT_TAB_DIR_L_R_H] = 0x00;
                              att_HDL_HIDS_REPORT_MSI[HDL_HIDS_REPORT_TAB_DIR_U_D_L] = 0xFF;
                              att_HDL_HIDS_REPORT_MSI[HDL_HIDS_REPORT_TAB_DIR_U_D_H] = 0xFF;
                          }
                          else if(HID_report_MS_key_temp <= 0xBF)
                          {
                              att_HDL_HIDS_REPORT_MSI[HDL_HIDS_REPORT_TAB_DIR_L_R_L] = 0x01;
                              att_HDL_HIDS_REPORT_MSI[HDL_HIDS_REPORT_TAB_DIR_L_R_H] = 0x00;
                              att_HDL_HIDS_REPORT_MSI[HDL_HIDS_REPORT_TAB_DIR_U_D_L] = 0x01;
                              att_HDL_HIDS_REPORT_MSI[HDL_HIDS_REPORT_TAB_DIR_U_D_H] = 0x00;
                          }
                          else if(HID_report_MS_key_temp <= 0xFF)
                          {
                              att_HDL_HIDS_REPORT_MSI[HDL_HIDS_REPORT_TAB_DIR_L_R_L] = 0xFF;
                              att_HDL_HIDS_REPORT_MSI[HDL_HIDS_REPORT_TAB_DIR_L_R_H] = 0xFF;
                              att_HDL_HIDS_REPORT_MSI[HDL_HIDS_REPORT_TAB_DIR_U_D_L] = 0x01;
                              att_HDL_HIDS_REPORT_MSI[HDL_HIDS_REPORT_TAB_DIR_U_D_H] = 0x00;
                          }
              
                          result = BLE_SendData(att_HDL_HIDS_REPORT_MSI,ATT_HDL_HIDS_REPORT_MSI_INIT,ATT_HDL_HIDS_REPORT
             -_MSI_INIT[4]);
                          if(result == SUCCESS)
                          {
                              mousedata = 0;
                          }
                          else
                          {
                              mousedata = 1;
                          }
                      }
                  }
                  else
                  {
                      result = BLE_SendData(att_HDL_HIDS_REPORT_MSI,ATT_HDL_HIDS_REPORT_MSI_INIT,ATT_HDL_HIDS_REPORT_MSI
             -_INIT[4]);
                      if(result == SUCCESS)
                      {
                          mousedata = 0;
                      }
                      else
                      {
                          mousedata = 1;
                      }
                  }
              #endif
 633   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    514    ----
   CONSTANT SIZE    =     96    ----
   XDATA SIZE       =      8      22
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.00   MAIN                                                                  07/12/2019 22:42:45 PAGE 12  

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
