C51 COMPILER V9.00   IO_PWM                                                                07/12/2019 22:42:44 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE IO_PWM
OBJECT MODULE PLACED IN ..\output\io_pwm.obj
COMPILER INVOKED BY: E:\developer kit tool\Keil_v5\C51\BIN\C51.EXE ..\code\source\io_pwm.c LARGE OPTIMIZE(9,SIZE) BROWSE
                    - NOAREGS INTVECTOR(0X0300) INCDIR(..\code\include) DEBUG OBJECTEXTEND PRINT(.\io_pwm.lst) TABS(2) OBJECT(..\output\io_pw
                    -m.obj)

line level    source

   1          
   2          #include "..\include\io_base.h"
   3          #include "..\include\io_pwm.h"
   4          #include "..\include\A8107.h"
   5          #include "..\include\servicegen.h"
   6          #include "..\include\LibFunction.h"
   7          #include "..\include\mcufunction.h"
   8          
   9          
  10          // ADC_Val 采集的最大值近似电压值为4.2 -- 3110    3.4v电压为2580
  11          #define min     2580
  12          #define max     3110
  13          #define level   100
  14          
  15          #define MaxValue 3110  
  16          
  17          #define rdFlashAddress 0x02fa
  18          /*--------------------------------------------------------------------------*/
  19          /* TYPE DEFINITION                                                          */
  20          /*--------------------------------------------------------------------------*/
  21          stConfigParam ConfigParam;
  22          
  23          bit          bcut_run;                      //led 指示参数
  24          uint8_t      led_duty_cycle;
  25          uint8_t      led_run_count;
  26          
  27          uint8_t      Motors_run_count;              //马达执行计数
  28          
  29          uint8_t      Vibration_count;
  30          
  31          
  32          bit          batterySend_ena;                    //是否使能电量通知
  33          bit          bWorkEna;                             //当前是否工作中
  34          
  35          bit          bNonProgrammeMotors_Ena;        //非编程马达震动使能位
  36          bit          bProgrammeMotors_Ena;          //编程马达使能位
  37          bit          bDivider_Ena;
  38          bit          bMotors_Ena;                     //马达震动使能位（在3.5v以上马达使能震动）
  39          
  40          uint8_t      exampleCount;                  //电量采集周期
  41          
  42          uint16_t     sec_base;                      //1s 基本时间
  43          bit          bTime_base_out;                  //单位时间标志
  44          uint8_t      xdata Buf[5];                      //反馈数据缓存
  45          
  46          /*--------------------------------------------------------------------------*/
  47          /* LOCAL FUNCTION PROTOTYPE                                                 */
  48          /*--------------------------------------------------------------------------*/
  49          uint16_t GetADC12BitValue(void);
  50          void BLE_SendDataPacket(uint8_t *sendBuf ,uint8_t sendSize);
  51          void detectCharge(void);
  52          void ledHint(bit enable);
  53          void motorShock(bit enable);
C51 COMPILER V9.00   IO_PWM                                                                07/12/2019 22:42:44 PAGE 2   

  54          void BatterySend(bit enable);
  55          void Work(bit enable);
  56          void clear(void);
  57          void reset(void);
  58          
  59          /*--------------------------------------------------------------------------*/
  60          /* LOCAL FUNCTIONS DEFINITION                                               */
  61          /*--------------------------------------------------------------------------*/
  62          /******************************************************
  63            delay
  64          *******************************************************/
  65          void Delay(uint16_t time)
  66          {
  67   1          uint16_t i,j;
  68   1          for (i=0; i<time; i++)
  69   1          {
  70   2              for (j=0; j<time; j++)
  71   2              {
  72   3                  ;
  73   3              }
  74   2          }
  75   1      }
  76          
  77          /**
  78          *   获取mac地址
  79          */
  80          void acquireMacAddress(void)
  81          {
  82   1          int flashAddress = rdFlashAddress;
  83   1          uint8_t mac[8],i;
  84   1          
  85   1          //头部
  86   1          mac[0] = 0xbf;
  87   1          mac[1] = 0xbf;
  88   1          
  89   1          for(i = 2; i < 6; i++)
  90   1          {
  91   2              mac[i] = CBYTE[flashAddress ++];
  92   2          }
  93   1          
  94   1          BLE_SendDataPacket(mac,sizeof(mac));
  95   1      }
  96          
  97          /**
  98           *  检测充电，
  99          **/
 100          void detectCharge(void)
 101          {
 102   1          P3OE  &= 0xFE;
 103   1          P3PUN |= 0x01;
 104   1      
 105   1          P3_0 = 1;
 106   1      //    Delay(3);
 107   1          if (P3_0 == 0)
 108   1          {
 109   2              // 没有充电
 110   2              Buf[0] = 0xcf;
 111   2              Buf[1] = 0xcf;
 112   2              Buf[2] = 0x00;
 113   2              BLE_SendDataPacket(Buf,3);
 114   2          }
 115   1          else
C51 COMPILER V9.00   IO_PWM                                                                07/12/2019 22:42:44 PAGE 3   

 116   1          {
 117   2              //正在充电
 118   2              Buf[0] = 0xcf;
 119   2              Buf[1] = 0xcf;
 120   2              Buf[2] = 0x01;
 121   2              BLE_SendDataPacket(Buf,3);
 122   2          }
 123   1      }
 124          
 125          // 得到0-100之间的值
 126          uint8_t getRate(sint16_t value)
 127          {
 128   1          if(value < 0)
 129   1              value = 0;
 130   1          else if(value > 100)
 131   1              value = 100;
 132   1      
 133   1          return value;
 134   1      }
 135          
 136          void sendBattery()
 137          {
 138   1          uint16_t ADC_Val;
 139   1          uint8_t averge = 0;
 140   1      
 141   1          //返回数据给手机
 142   1          //获取电压的值。
 143   1      
 144   1      
 145   1          ADC_Val = GetADC12BitValue();
 146   1          
 147   1          
 148   1          averge = (ADC_Val - min) / (float)(MaxValue - min) * level;
 149   1      
 150   1          if(averge > 100)
 151   1              averge = 100;
 152   1          
 153   1          if(averge < 0)
 154   1              averge = 0;
 155   1          
 156   1      
 157   1      //    averge = getRate((ADC_Val - min) / 5);///(max - min) * level;
 158   1      //    averge = (float)(ADC_Val - min)/(float)(max - min) * level;
 159   1      
 160   1          Buf[0] = 0xcd;
 161   1          Buf[1] = 0XCD;
 162   1          Buf[2] = averge;
 163   1          Buf[3] = ADC_Val / 256;
 164   1          Buf[4] = ADC_Val % 256;
 165   1      
 166   1      //   Buf[4] = 0xaa;
 167   1          BLE_SendDataPacket(Buf,5);
 168   1      }
 169          
 170          
 171          uint8_t type = 0;
 172          void HandlerData(uint8_t *Buf)
 173          {
 174   1          uint8_t tmp;
 175   1      
 176   1      
 177   1          //接受收据处理
C51 COMPILER V9.00   IO_PWM                                                                07/12/2019 22:42:44 PAGE 4   

 178   1          if(Buf[5]==0X82 && Buf[0]==0XBB)
 179   1          {
 180   2              tmp = (Buf[5]+Buf[4]+Buf[3]+Buf[2])&0xFF;
 181   2      
 182   2              if(Buf[1]==tmp)//校验数据
 183   2             {
 184   3      
 185   3              //判断是否有休息指令
 186   3              if((Buf[3] & 0x08) != 0)
 187   3              {
 188   4      
 189   4                  //使能休眠标志位
 190   4                  //    setIntoSleepFlag(TRUE);
 191   4                  IntoSleepFlag = TRUE;
 192   4      
 193   4                  //断开连接
 194   4                  BLE_SetTerminate();
 195   4                
 196   4      
 197   4                  return;
 198   4              }
 199   3              
 200   3              //判断是获取mac地址
 201   3              if(Buf[3] & 0x10)
 202   3              {
 203   4                  acquireMacAddress();
 204   4              }
 205   3              
 206   3      
 207   3              // 控制方式
 208   3              ConfigParam.ControlType = (emControlType)(Buf[3] & 0x03);
 209   3      
 210   3              //使能马达震动位bit2
 211   3              if(Buf[3] & 0x04)
 212   3              {
 213   4                  bMotors_Ena = FALSE;
 214   4                  clear();
 215   4              }
 216   3              else
 217   3              {
 218   4                  bMotors_Ena = TRUE;
 219   4              }
 220   3      
 221   3              //当马达禁止震动时（低电压时）不接受指令操作。
 222   3              if(!bMotors_Ena) return;
 223   3      
 224   3              if (Buf[2] == 0)//有无基本编程
 225   3              {
 226   4                  if (Buf[4] & 0x80)
 227   4                  {
 228   5                      //使能马达控制
 229   5                      bNonProgrammeMotors_Ena = TRUE;
 230   5                      //马达工作周期
 231   5                      ConfigParam.Motors_duty_cycle = Buf[4] & 0x7f;
 232   5                  }
 233   4                  else
 234   4                  {
 235   5                      clear();
 236   5                  }
 237   4              }
 238   3              else if (!(ConfigParam.ShockType & 0x0f))
 239   3              {
C51 COMPILER V9.00   IO_PWM                                                                07/12/2019 22:42:44 PAGE 5   

 240   4                  bProgrammeMotors_Ena = TRUE;
 241   4                  ConfigParam.ShockType = (emShockType)(Buf[2] & 0x0f);
 242   4                  Vibration_count = 0;
 243   4              }
 244   3             }
 245   2          }
 246   1      }
 247          
 248          void clear(void)
 249          {
 250   1          //停止震动
 251   1          bNonProgrammeMotors_Ena = FALSE;
 252   1      
 253   1          //震动方式
 254   1          ConfigParam.ShockType = 0;
 255   1      
 256   1          bProgrammeMotors_Ena = FALSE;
 257   1          Vibration_count = 0;
 258   1      }
 259          
 260          /*****************************************************************************
 261              @fn         uint16_t GetADC12BitValue(void)
 262              @brief      Obtain 12bit ADC value
 263              @param      N/A
 264              @return     ADC value
 265          *****************************************************************************/
 266          uint16_t GetADC12BitValue(void)
 267          {
 268   1          uint16_t tmp;
 269   1          
 270   1          /* User can modify ADC analog input pin (Default Selection P3.1)*/
 271   1          P3OE &= 0xFD;
 272   1          P3PUN |= ~0xFD;
 273   1          ADCCH = 0x0F; // Enable ADC analog input and Select P3.1 as ADC analog input.
 274   1      
 275   1          /* ADC Setting and Running */
 276   1          XBYTE[EXT1_REG] = 0x58;     // Disable REGR
 277   1          XBYTE[ADCAVG1_REG] = 0x02; // Enable the SAR ADC
 278   1          XBYTE[ADCCTL_REG] = 0x01; // Single mode and ADC measurement enable
 279   1          tmp = 0;
 280   1          while (XBYTE[ADCCTL_REG] & 0x01);
 281   1          tmp = (XBYTE[ADCAVG1_REG] & 0xF0);
 282   1          tmp <<= 4;
 283   1          tmp |= XBYTE[ADCAVG2_REG];
 284   1          XBYTE[ADCCTL_REG] = 0x00;
 285   1          XBYTE[ADCAVG1_REG] = 0x00;
 286   1          ADCCH &= 0xFE; // Disable ADC analog input.
 287   1          return tmp;
 288   1      }
 289          
 290          void connected_init(void)
 291          {
 292   1          if(!bWorkEna)
 293   1          {
 294   2              enable_timer1();
 295   2              Work(TRUE);
 296   2              sendBattery();
 297   2          }
 298   1      }
 299          
 300          void timer_detect(void)
 301          {
C51 COMPILER V9.00   IO_PWM                                                                07/12/2019 22:42:44 PAGE 6   

 302   1          if (ConfigParam.ClkTickCtr >= 500)//50ms
 303   1          {
 304   2              ConfigParam.ClkTickCtr = 0;
 305   2      
 306   2              bTime_base_out = TRUE;
 307   2              sec_base ++;
 308   2      
 309   2              if (sec_base >= 30)//2s
 310   2              {
 311   3                  if(sec_base == 30)
 312   3                      detectCharge();
 313   3      
 314   3                  if(sec_base >= 60) {
 315   4                      sec_base = 0;
 316   4                      sendBattery();
 317   4                  }
 318   3              }
 319   2          }
 320   1      }
 321          
 322          
 323          
 324          void BatterySend(bit enable)
 325          {
 326   1          batterySend_ena = enable;
 327   1      }
 328          
 329          void Work(bit enable)
 330          {
 331   1          bWorkEna = enable;
 332   1      }
 333          
 334          /*
 335           *空中升级需要关闭定时器，以免影响升级
 336           */
 337          void update_init(void)
 338          {
 339   1          disable_timer1();
 340   1      }
 341          
 342          
 343          void pwm_init(void)
 344          {
 345   1          motorShock(RESET);  // 马达控制初始为低
 346   1      
 347   1          ledHint(RESET);      // 工作指示
 348   1      
 349   1      
 350   1          ConfigParam.Motors_duty_cycle = 100;
 351   1          bNonProgrammeMotors_Ena = FALSE;
 352   1          bProgrammeMotors_Ena = FALSE;
 353   1          bDivider_Ena = FALSE;
 354   1          bMotors_Ena  = TRUE;
 355   1          ConfigParam.ClkTickCtr = 0;
 356   1      
 357   1          Motors_run_count = 0;
 358   1      
 359   1          bcut_run = 1;
 360   1          led_duty_cycle = 6;
 361   1          led_run_count = 0;
 362   1      
 363   1      
C51 COMPILER V9.00   IO_PWM                                                                07/12/2019 22:42:44 PAGE 7   

 364   1          Vibration_count = 0;
 365   1      }
 366          
 367          #if 0
              void reset(void)
              {
              
                  disable_timer1();
                  Work(FALSE); /* 板濮bWorkEnaㄥ涓哄 */
              /*    ledHint(RESET);
                  motorShock(DISABLE);
              
              
              
                  ConfigParam.Motors_duty_cycle = 100;
                  led_duty_cycle = 6;
                  bProgrammeMotors_Ena = FALSE;
                  bNonProgrammeMotors_Ena = FALSE;
                  bDivider_Ena = FALSE;
                  bMotors_Ena  = TRUE;
                  ConfigParam.ShockType = sync;
                  ConfigParam.ClkTickCtr = 0;
                  Motors_run_count = 0;
              */
              }
              #endif
 390          
 391          void BLE_SendDataPacket(uint8_t *sendBuf ,uint8_t sendSize)
 392          {
 393   1          if((att_HDL_USER_DEFINE_01_DATAN01_CLIENT_CHARACTERISTIC_CONFIGURATION[0] 
 394   1              & GATT_DESCRIPTORS_CLIENT_CHARACTERISTIC_CONFIGURATION_NOTIFICATION) != 0){
 395   2              BLE_SendData(sendBuf,ATT_HDL_USER_DEFINE_01_DATAN01_INIT,sendSize);
 396   2          }
 397   1      }
 398          
 399          void motorShock(bit enable)
 400          {
 401   1          switch(ConfigParam.ControlType)
 402   1          {
 403   2          case left:
 404   2              MOTOR1 = enable;
 405   2              MOTOR2 = DISABLE;
 406   2              break;
 407   2          case right:
 408   2              MOTOR1 = DISABLE;
 409   2              MOTOR2 = enable;
 410   2              break;
 411   2          case sync:
 412   2              MOTOR1 = enable;
 413   2              MOTOR2 = enable;
 414   2              break;
 415   2      
 416   2          default:
 417   2              break;
 418   2          }
 419   1      }
 420          
 421          void ledHint(bit enable)
 422          {
 423   1          LED_WORK_GREEN = enable;
 424   1      }
 425          
C51 COMPILER V9.00   IO_PWM                                                                07/12/2019 22:42:44 PAGE 8   

 426          void pwm_deal(void)
 427          {
 428   1      
 429   1          if(!bDivider_Ena && bNonProgrammeMotors_Ena == TRUE)
 430   1          {
 431   2              Motors_run_count ++;
 432   2              if (Motors_run_count > 99)
 433   2              {
 434   3                  Motors_run_count = 0;
 435   3              }
 436   2              if (Motors_run_count >= ConfigParam.Motors_duty_cycle)
 437   2              {
 438   3                  motorShock(RESET);
 439   3              }
 440   2              else
 441   2              {
 442   3                  motorShock(SET);
 443   3              }
 444   2          }
 445   1          else
 446   1          {
 447   2              motorShock(RESET);
 448   2          }
 449   1      
 450   1      
 451   1          //工作指示
 452   1          if (bWorkEna == TRUE)
 453   1          {
 454   2              led_run_count ++;
 455   2              if (led_run_count >= 150)   //
 456   2              {
 457   3                  led_run_count = 0;
 458   3              }
 459   2              if (led_run_count >= led_duty_cycle)
 460   2              {
 461   3                  ledHint(RESET);
 462   3              }
 463   2              else
 464   2              {
 465   3                  ledHint(SET);
 466   3              }
 467   2          }
 468   1          else
 469   1          {
 470   2              led_run_count = 0;
 471   2          }
 472   1      }
 473          
 474          void mode_stop(void)
 475          {
 476   1          Vibration_count = 0;
 477   1          bNonProgrammeMotors_Ena = FALSE;
 478   1          ConfigParam.Motors_duty_cycle = 0;
 479   1      
 480   1          Buf[0] = 0XAB;
 481   1          Buf[1] = 0XAB;
 482   1          Buf[2] = ConfigParam.ShockType;
 483   1          Buf[3] = ConfigParam.ShockType;
 484   1          BLE_SendDataPacket((uint8_t*)Buf,4);
 485   1      
 486   1          ConfigParam.ShockType = nc;
 487   1      }
C51 COMPILER V9.00   IO_PWM                                                                07/12/2019 22:42:44 PAGE 9   

 488          
 489          
 490          void sub_function(void)
 491          {
 492   1          if(bNonProgrammeMotors_Ena == TRUE && bProgrammeMotors_Ena == FALSE)
 493   1          {
 494   2              if (bTime_base_out == SET)
 495   2              {
 496   3                  if (Vibration_count % ConfigParam.Vibration_Stand == 0)
 497   3                  {
 498   4                      bDivider_Ena = !bDivider_Ena;
 499   4                  }
 500   3                  if (Vibration_count < 60)
 501   3                  {
 502   4                      Vibration_count ++;
 503   4                  }
 504   3                  else
 505   3                  {
 506   4                      Vibration_count = 0;
 507   4                  }
 508   3              }
 509   2      
 510   2              bTime_base_out = RESET;
 511   2          }
 512   1      
 513   1          if(bProgrammeMotors_Ena != TRUE)
 514   1              return;
 515   1      
 516   1      
 517   1          bDivider_Ena = FALSE;
 518   1      
 519   1          switch(ConfigParam.ShockType)//振动
 520   1          {
 521   2          case soft://弱到强
 522   2              bNonProgrammeMotors_Ena = TRUE;
 523   2              if (bTime_base_out == SET)
 524   2              {
 525   3                  if (ConfigParam.Motors_duty_cycle < 99)
 526   3                  {
 527   4                      ConfigParam.Motors_duty_cycle += 2;
 528   4                  }
 529   3                  else
 530   3                  {
 531   4                      mode_stop();
 532   4                  }
 533   3              }
 534   2      
 535   2              break;
 536   2          case ripple://弱振
 537   2              bNonProgrammeMotors_Ena = TRUE;
 538   2              ConfigParam.Motors_duty_cycle = 50;
 539   2              if (bTime_base_out == SET)
 540   2              {
 541   3                  if (Vibration_count < 60)
 542   3                  {
 543   4                      Vibration_count ++;
 544   4                  }
 545   3                  else
 546   3                  {
 547   4                      mode_stop();
 548   4                  }
 549   3              }
C51 COMPILER V9.00   IO_PWM                                                                07/12/2019 22:42:44 PAGE 10  

 550   2              break;
 551   2          case slow://振0.2  停0.2
 552   2              if (bTime_base_out == SET)
 553   2              {
 554   3                  Vibration_count ++;
 555   3                  if (Vibration_count % 4 == 0)
 556   3                  {
 557   4                      bNonProgrammeMotors_Ena = !bNonProgrammeMotors_Ena;
 558   4                      ConfigParam.Motors_duty_cycle = 100;
 559   4                  }
 560   3                  if (Vibration_count == 60)
 561   3                  {
 562   4                      mode_stop();
 563   4                  }
 564   3              }
 565   2              break;
 566   2          case strong://强振
 567   2              bNonProgrammeMotors_Ena = TRUE;
 568   2              ConfigParam.Motors_duty_cycle = 100;
 569   2              if (bTime_base_out == SET)
 570   2              {
 571   3                  if (Vibration_count < 60)
 572   3                  {
 573   4                      Vibration_count ++;
 574   4      
 575   4                  }
 576   3                  else
 577   3                  {
 578   4                      mode_stop();
 579   4                  }
 580   3              }
 581   2      
 582   2              break;
 583   2          case dynamism: //动感
 584   2              ConfigParam.Motors_duty_cycle = 100;
 585   2      //    bNonProgrammeMotors_Ena = TRUE;
 586   2              if (bTime_base_out == SET)
 587   2              {
 588   3                  if (Vibration_count % ConfigParam.Vibration_Stand == 0)
 589   3                  {
 590   4                      bNonProgrammeMotors_Ena = !bNonProgrammeMotors_Ena;
 591   4                  }
 592   3                  if (Vibration_count < 60)
 593   3                  {
 594   4                      Vibration_count ++;
 595   4                  }
 596   3                  else
 597   3                  {
 598   4                      mode_stop();
 599   4                  }
 600   3              }
 601   2              break;
 602   2          default:
 603   2              break;
 604   2          }
 605   1      
 606   1          bTime_base_out = RESET;
 607   1      }
 608          
 609          
 610          
 611          
C51 COMPILER V9.00   IO_PWM                                                                07/12/2019 22:42:44 PAGE 11  

 612          
 613          
 614          
 615          
 616          
 617          
 618          
 619          
 620          
 621          
 622          
 623          
 624          
 625          
 626          
 627          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1126    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     19      13
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8       4
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
